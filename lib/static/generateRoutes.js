"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _path = _interopRequireDefault(require("path"));

var _slash = _interopRequireDefault(require("slash"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var _default =
/*#__PURE__*/
function () {
  var _ref2 = _asyncToGenerator(
  /*#__PURE__*/
  _regenerator.default.mark(function _callee(_ref) {
    var config, templates, routes, paths, route404, id404, productionImports, developmentImports, productionTemplates, developmentTemplates, file, dynamicRoutesPath;
    return _regenerator.default.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            config = _ref.config;
            templates = config.templates, routes = config.routes, paths = config.paths;
            route404 = routes.find(function (route) {
              return route.path === '404';
            });
            id404 = route404.templateID;
            productionImports = "\nimport universal, { setHasBabelPlugin } from 'react-universal-component'\n  ";
            developmentImports = '';
            productionTemplates = "\n\nconst universalOptions = {\n  loading: () => null,\n  error: props => {\n    console.error(props.error);\n    return <div>An error occurred loading this page's template. More information is available in the console.</div>;\n  },\n}\n\n".concat(templates.map(function (template, index) {
              var templatePath = _path.default.relative(paths.DIST, _path.default.resolve(paths.ROOT, template));

              return "const t_".concat(index, " = require('").concat((0, _slash.default)(templatePath), "').default");
            }).join('\n'), "\n");
            developmentTemplates = templates.map(function (template, index) {
              var templatePath = _path.default.relative(paths.DIST, _path.default.resolve(paths.ROOT, template));

              return "import t_".concat(index, " from '").concat((0, _slash.default)(templatePath), "'");
            }).join('\n');
            file = "\nimport React, { Component } from 'react'\nimport { Route } from 'react-router-dom'\nimport { cleanPath } from 'react-static'\n".concat(process.env.NODE_ENV === 'production' ? productionImports : developmentImports, "\n\n").concat(process.env.NODE_ENV === 'production' ? productionTemplates : developmentTemplates, "\n\n// Template Map\nglobal.componentsByTemplateID = global.componentsByTemplateID || [\n  ").concat(templates.map(function (template, index) {
              return "t_".concat(index);
            }).join(',\n'), "\n]\n\nconst defaultTemplateIDs = {\n  '404': ").concat(id404, "\n}\n\n// Template Tree\nglobal.templateIDsByPath = global.templateIDsByPath || defaultTemplateIDs\n\n// Get template for given path\nconst getComponentForPath = path => {\n  path = cleanPath(path)\n  return global.componentsByTemplateID[global.templateIDsByPath[path]]\n}\n\nglobal.reactStaticGetComponentForPath = getComponentForPath\nglobal.reactStaticRegisterTemplateIDForPath = (path, id) => {\n  global.templateIDsByPath[path] = id\n}\nglobal.clearTemplateIDs = () => {\n  global.templateIDsByPath = defaultTemplateIDs\n}\n\nexport default class Routes extends Component {\n  componentDidMount () {\n    global.clearTemplateIDs = () => {\n      this.setState({})\n    }\n    ").concat(process.env.NODE_ENV !== 'production' ? "\n    if (typeof document !== 'undefined' && module.hot) {\n      ".concat(templates.map(function (template, index) {
              var templatePath = _path.default.relative(paths.DIST, _path.default.resolve(paths.ROOT, template));

              return "module.hot.accept('".concat((0, _slash.default)(templatePath), "', () => {\n            global.componentsByTemplateID[").concat(index, "] = require('").concat((0, _slash.default)(templatePath), "').default\n            this.forceUpdate()\n          })");
            }).join('\n'), "\n      }\n") : '', "\n\n  }\n  render () {\n    const { component: Comp, render, children } = this.props\n\n    const getFullComponentForPath = path => {\n      let Comp = getComponentForPath(path)\n      let is404 = path === '404'\n      if (!Comp) {\n        is404 = true\n        Comp = getComponentForPath('/404')\n      }\n      return (newProps = {}) => (\n        Comp\n          ? <Comp {...newProps} {...(is404 ? {path: '404'} : {})} />\n          : null\n      )\n    }\n\n    const renderProps = {\n      componentsByTemplateID: global.componentsByTemplateID,\n      templateIDsByPath: global.templateIDsByPath,\n      getComponentForPath: getFullComponentForPath\n    }\n\n    if (Comp) {\n      return (\n        <Comp\n          {...renderProps}\n        />\n      )\n    }\n\n    if (render || children) {\n      return (render || children)(renderProps)\n    }\n\n    // This is the default auto-routing renderer\n    return (\n      <Route render={props => {\n        let Comp = getFullComponentForPath(props.location.pathname)\n        // If Comp is used as a component here, it triggers React to re-mount the entire\n        // component tree underneath during reconciliation, losing all internal state.\n        // By unwrapping it here we keep the real, static component exposed directly to React.\n        return Comp && Comp()\n      }} />\n    )\n  }\n}\n\n");
            dynamicRoutesPath = _path.default.join(paths.DIST, 'react-static-routes.js');
            _context.next = 12;
            return _fsExtra.default.remove(dynamicRoutesPath);

          case 12:
            _context.next = 14;
            return _fsExtra.default.outputFile(dynamicRoutesPath, file);

          case 14:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, this);
  }));

  return function (_x) {
    return _ref2.apply(this, arguments);
  };
}();

exports.default = _default;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9zdGF0aWMvZ2VuZXJhdGVSb3V0ZXMuanMiXSwibmFtZXMiOlsiY29uZmlnIiwidGVtcGxhdGVzIiwicm91dGVzIiwicGF0aHMiLCJyb3V0ZTQwNCIsImZpbmQiLCJyb3V0ZSIsInBhdGgiLCJpZDQwNCIsInRlbXBsYXRlSUQiLCJwcm9kdWN0aW9uSW1wb3J0cyIsImRldmVsb3BtZW50SW1wb3J0cyIsInByb2R1Y3Rpb25UZW1wbGF0ZXMiLCJtYXAiLCJ0ZW1wbGF0ZSIsImluZGV4IiwidGVtcGxhdGVQYXRoIiwicmVsYXRpdmUiLCJESVNUIiwicmVzb2x2ZSIsIlJPT1QiLCJqb2luIiwiZGV2ZWxvcG1lbnRUZW1wbGF0ZXMiLCJmaWxlIiwicHJvY2VzcyIsImVudiIsIk5PREVfRU5WIiwiZHluYW1pY1JvdXRlc1BhdGgiLCJmcyIsInJlbW92ZSIsIm91dHB1dEZpbGUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7OztBQUFBOztBQUNBOztBQUNBOzs7Ozs7Ozs7Ozs7OzRCQUVlO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFTQSxZQUFBQSxNQUFULFFBQVNBLE1BQVQ7QUFDTEMsWUFBQUEsU0FESyxHQUN3QkQsTUFEeEIsQ0FDTEMsU0FESyxFQUNNQyxNQUROLEdBQ3dCRixNQUR4QixDQUNNRSxNQUROLEVBQ2NDLEtBRGQsR0FDd0JILE1BRHhCLENBQ2NHLEtBRGQ7QUFHUEMsWUFBQUEsUUFITyxHQUdJRixNQUFNLENBQUNHLElBQVAsQ0FBWSxVQUFBQyxLQUFLO0FBQUEscUJBQUlBLEtBQUssQ0FBQ0MsSUFBTixLQUFlLEtBQW5CO0FBQUEsYUFBakIsQ0FISjtBQUlQQyxZQUFBQSxLQUpPLEdBSUNKLFFBQVEsQ0FBQ0ssVUFKVjtBQU1QQyxZQUFBQSxpQkFOTztBQVNQQyxZQUFBQSxrQkFUTyxHQVNjLEVBVGQ7QUFXUEMsWUFBQUEsbUJBWE8sNFBBcUJiWCxTQUFTLENBQ05ZLEdBREgsQ0FDTyxVQUFDQyxRQUFELEVBQVdDLEtBQVgsRUFBcUI7QUFDeEIsa0JBQU1DLFlBQVksR0FBR1QsY0FBS1UsUUFBTCxDQUNuQmQsS0FBSyxDQUFDZSxJQURhLEVBRW5CWCxjQUFLWSxPQUFMLENBQWFoQixLQUFLLENBQUNpQixJQUFuQixFQUF5Qk4sUUFBekIsQ0FGbUIsQ0FBckI7O0FBSUEsdUNBQWtCQyxLQUFsQix5QkFBc0Msb0JBQU1DLFlBQU4sQ0FBdEM7QUFDRCxhQVBILEVBUUdLLElBUkgsQ0FRUSxJQVJSLENBckJhO0FBZ0NQQyxZQUFBQSxvQkFoQ08sR0FnQ2dCckIsU0FBUyxDQUNuQ1ksR0FEMEIsQ0FDdEIsVUFBQ0MsUUFBRCxFQUFXQyxLQUFYLEVBQXFCO0FBQ3hCLGtCQUFNQyxZQUFZLEdBQUdULGNBQUtVLFFBQUwsQ0FDbkJkLEtBQUssQ0FBQ2UsSUFEYSxFQUVuQlgsY0FBS1ksT0FBTCxDQUFhaEIsS0FBSyxDQUFDaUIsSUFBbkIsRUFBeUJOLFFBQXpCLENBRm1CLENBQXJCOztBQUlBLHdDQUFtQkMsS0FBbkIsb0JBQWtDLG9CQUFNQyxZQUFOLENBQWxDO0FBQ0QsYUFQMEIsRUFRMUJLLElBUjBCLENBUXJCLElBUnFCLENBaENoQjtBQTBDUEUsWUFBQUEsSUExQ08sNklBK0NYQyxPQUFPLENBQUNDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUF6QixHQUNJaEIsaUJBREosR0FFSUMsa0JBakRPLGlCQXFEWGEsT0FBTyxDQUFDQyxHQUFSLENBQVlDLFFBQVosS0FBeUIsWUFBekIsR0FDSWQsbUJBREosR0FFSVUsb0JBdkRPLHdHQTREWHJCLFNBQVMsQ0FBQ1ksR0FBVixDQUFjLFVBQUNDLFFBQUQsRUFBV0MsS0FBWDtBQUFBLGlDQUEwQkEsS0FBMUI7QUFBQSxhQUFkLEVBQWlETSxJQUFqRCxDQUFzRCxLQUF0RCxDQTVEVywyREFnRUpiLEtBaEVJLHNyQkEwRlRnQixPQUFPLENBQUNDLEdBQVIsQ0FBWUMsUUFBWixLQUF5QixZQUF6QiwrRUFHRXpCLFNBQVMsQ0FDUlksR0FERCxDQUNLLFVBQUNDLFFBQUQsRUFBV0MsS0FBWCxFQUFxQjtBQUN4QixrQkFBTUMsWUFBWSxHQUFHVCxjQUFLVSxRQUFMLENBQ25CZCxLQUFLLENBQUNlLElBRGEsRUFFbkJYLGNBQUtZLE9BQUwsQ0FBYWhCLEtBQUssQ0FBQ2lCLElBQW5CLEVBQXlCTixRQUF6QixDQUZtQixDQUFyQjs7QUFJQSxrREFBNkIsb0JBQU1FLFlBQU4sQ0FBN0IsbUVBQ2tDRCxLQURsQywwQkFDdUQsb0JBQ3JEQyxZQURxRCxDQUR2RDtBQU1ELGFBWkQsRUFhQ0ssSUFiRCxDQWFNLElBYk4sQ0FIRixtQkFtQkksRUE3R0s7QUFtS1BNLFlBQUFBLGlCQW5LTyxHQW1LYXBCLGNBQUtjLElBQUwsQ0FBVWxCLEtBQUssQ0FBQ2UsSUFBaEIsRUFBc0Isd0JBQXRCLENBbktiO0FBQUE7QUFBQSxtQkFvS1BVLGlCQUFHQyxNQUFILENBQVVGLGlCQUFWLENBcEtPOztBQUFBO0FBQUE7QUFBQSxtQkFxS1BDLGlCQUFHRSxVQUFILENBQWNILGlCQUFkLEVBQWlDSixJQUFqQyxDQXJLTzs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxHIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHBhdGggZnJvbSAncGF0aCdcbmltcG9ydCBzbGFzaCBmcm9tICdzbGFzaCdcbmltcG9ydCBmcyBmcm9tICdmcy1leHRyYSdcblxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgKHsgY29uZmlnIH0pID0+IHtcbiAgY29uc3QgeyB0ZW1wbGF0ZXMsIHJvdXRlcywgcGF0aHMgfSA9IGNvbmZpZ1xuXG4gIGNvbnN0IHJvdXRlNDA0ID0gcm91dGVzLmZpbmQocm91dGUgPT4gcm91dGUucGF0aCA9PT0gJzQwNCcpXG4gIGNvbnN0IGlkNDA0ID0gcm91dGU0MDQudGVtcGxhdGVJRFxuXG4gIGNvbnN0IHByb2R1Y3Rpb25JbXBvcnRzID0gYFxuaW1wb3J0IHVuaXZlcnNhbCwgeyBzZXRIYXNCYWJlbFBsdWdpbiB9IGZyb20gJ3JlYWN0LXVuaXZlcnNhbC1jb21wb25lbnQnXG4gIGBcbiAgY29uc3QgZGV2ZWxvcG1lbnRJbXBvcnRzID0gJydcblxuICBjb25zdCBwcm9kdWN0aW9uVGVtcGxhdGVzID0gYFxuXG5jb25zdCB1bml2ZXJzYWxPcHRpb25zID0ge1xuICBsb2FkaW5nOiAoKSA9PiBudWxsLFxuICBlcnJvcjogcHJvcHMgPT4ge1xuICAgIGNvbnNvbGUuZXJyb3IocHJvcHMuZXJyb3IpO1xuICAgIHJldHVybiA8ZGl2PkFuIGVycm9yIG9jY3VycmVkIGxvYWRpbmcgdGhpcyBwYWdlJ3MgdGVtcGxhdGUuIE1vcmUgaW5mb3JtYXRpb24gaXMgYXZhaWxhYmxlIGluIHRoZSBjb25zb2xlLjwvZGl2PjtcbiAgfSxcbn1cblxuJHt0ZW1wbGF0ZXNcbiAgICAubWFwKCh0ZW1wbGF0ZSwgaW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IHRlbXBsYXRlUGF0aCA9IHBhdGgucmVsYXRpdmUoXG4gICAgICAgIHBhdGhzLkRJU1QsXG4gICAgICAgIHBhdGgucmVzb2x2ZShwYXRocy5ST09ULCB0ZW1wbGF0ZSlcbiAgICAgIClcbiAgICAgIHJldHVybiBgY29uc3QgdF8ke2luZGV4fSA9IHJlcXVpcmUoJyR7c2xhc2godGVtcGxhdGVQYXRoKX0nKS5kZWZhdWx0YFxuICAgIH0pXG4gICAgLmpvaW4oJ1xcbicpfVxuYFxuXG4gIGNvbnN0IGRldmVsb3BtZW50VGVtcGxhdGVzID0gdGVtcGxhdGVzXG4gICAgLm1hcCgodGVtcGxhdGUsIGluZGV4KSA9PiB7XG4gICAgICBjb25zdCB0ZW1wbGF0ZVBhdGggPSBwYXRoLnJlbGF0aXZlKFxuICAgICAgICBwYXRocy5ESVNULFxuICAgICAgICBwYXRoLnJlc29sdmUocGF0aHMuUk9PVCwgdGVtcGxhdGUpXG4gICAgICApXG4gICAgICByZXR1cm4gYGltcG9ydCB0XyR7aW5kZXh9IGZyb20gJyR7c2xhc2godGVtcGxhdGVQYXRoKX0nYFxuICAgIH0pXG4gICAgLmpvaW4oJ1xcbicpXG5cbiAgY29uc3QgZmlsZSA9IGBcbmltcG9ydCBSZWFjdCwgeyBDb21wb25lbnQgfSBmcm9tICdyZWFjdCdcbmltcG9ydCB7IFJvdXRlIH0gZnJvbSAncmVhY3Qtcm91dGVyLWRvbSdcbmltcG9ydCB7IGNsZWFuUGF0aCB9IGZyb20gJ3JlYWN0LXN0YXRpYydcbiR7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJ1xuICAgICAgPyBwcm9kdWN0aW9uSW1wb3J0c1xuICAgICAgOiBkZXZlbG9wbWVudEltcG9ydHNcbiAgfVxuXG4ke1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbidcbiAgICAgID8gcHJvZHVjdGlvblRlbXBsYXRlc1xuICAgICAgOiBkZXZlbG9wbWVudFRlbXBsYXRlc1xuICB9XG5cbi8vIFRlbXBsYXRlIE1hcFxuZ2xvYmFsLmNvbXBvbmVudHNCeVRlbXBsYXRlSUQgPSBnbG9iYWwuY29tcG9uZW50c0J5VGVtcGxhdGVJRCB8fCBbXG4gICR7dGVtcGxhdGVzLm1hcCgodGVtcGxhdGUsIGluZGV4KSA9PiBgdF8ke2luZGV4fWApLmpvaW4oJyxcXG4nKX1cbl1cblxuY29uc3QgZGVmYXVsdFRlbXBsYXRlSURzID0ge1xuICAnNDA0JzogJHtpZDQwNH1cbn1cblxuLy8gVGVtcGxhdGUgVHJlZVxuZ2xvYmFsLnRlbXBsYXRlSURzQnlQYXRoID0gZ2xvYmFsLnRlbXBsYXRlSURzQnlQYXRoIHx8IGRlZmF1bHRUZW1wbGF0ZUlEc1xuXG4vLyBHZXQgdGVtcGxhdGUgZm9yIGdpdmVuIHBhdGhcbmNvbnN0IGdldENvbXBvbmVudEZvclBhdGggPSBwYXRoID0+IHtcbiAgcGF0aCA9IGNsZWFuUGF0aChwYXRoKVxuICByZXR1cm4gZ2xvYmFsLmNvbXBvbmVudHNCeVRlbXBsYXRlSURbZ2xvYmFsLnRlbXBsYXRlSURzQnlQYXRoW3BhdGhdXVxufVxuXG5nbG9iYWwucmVhY3RTdGF0aWNHZXRDb21wb25lbnRGb3JQYXRoID0gZ2V0Q29tcG9uZW50Rm9yUGF0aFxuZ2xvYmFsLnJlYWN0U3RhdGljUmVnaXN0ZXJUZW1wbGF0ZUlERm9yUGF0aCA9IChwYXRoLCBpZCkgPT4ge1xuICBnbG9iYWwudGVtcGxhdGVJRHNCeVBhdGhbcGF0aF0gPSBpZFxufVxuZ2xvYmFsLmNsZWFyVGVtcGxhdGVJRHMgPSAoKSA9PiB7XG4gIGdsb2JhbC50ZW1wbGF0ZUlEc0J5UGF0aCA9IGRlZmF1bHRUZW1wbGF0ZUlEc1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSb3V0ZXMgZXh0ZW5kcyBDb21wb25lbnQge1xuICBjb21wb25lbnREaWRNb3VudCAoKSB7XG4gICAgZ2xvYmFsLmNsZWFyVGVtcGxhdGVJRHMgPSAoKSA9PiB7XG4gICAgICB0aGlzLnNldFN0YXRlKHt9KVxuICAgIH1cbiAgICAke1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xuICAgICAgICA/IGBcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuaG90KSB7XG4gICAgICAke3RlbXBsYXRlc1xuICAgICAgICAubWFwKCh0ZW1wbGF0ZSwgaW5kZXgpID0+IHtcbiAgICAgICAgICBjb25zdCB0ZW1wbGF0ZVBhdGggPSBwYXRoLnJlbGF0aXZlKFxuICAgICAgICAgICAgcGF0aHMuRElTVCxcbiAgICAgICAgICAgIHBhdGgucmVzb2x2ZShwYXRocy5ST09ULCB0ZW1wbGF0ZSlcbiAgICAgICAgICApXG4gICAgICAgICAgcmV0dXJuIGBtb2R1bGUuaG90LmFjY2VwdCgnJHtzbGFzaCh0ZW1wbGF0ZVBhdGgpfScsICgpID0+IHtcbiAgICAgICAgICAgIGdsb2JhbC5jb21wb25lbnRzQnlUZW1wbGF0ZUlEWyR7aW5kZXh9XSA9IHJlcXVpcmUoJyR7c2xhc2goXG4gICAgICAgICAgICB0ZW1wbGF0ZVBhdGhcbiAgICAgICAgICApfScpLmRlZmF1bHRcbiAgICAgICAgICAgIHRoaXMuZm9yY2VVcGRhdGUoKVxuICAgICAgICAgIH0pYFxuICAgICAgICB9KVxuICAgICAgICAuam9pbignXFxuJyl9XG4gICAgICB9XG5gXG4gICAgICAgIDogJydcbiAgICB9XG5cbiAgfVxuICByZW5kZXIgKCkge1xuICAgIGNvbnN0IHsgY29tcG9uZW50OiBDb21wLCByZW5kZXIsIGNoaWxkcmVuIH0gPSB0aGlzLnByb3BzXG5cbiAgICBjb25zdCBnZXRGdWxsQ29tcG9uZW50Rm9yUGF0aCA9IHBhdGggPT4ge1xuICAgICAgbGV0IENvbXAgPSBnZXRDb21wb25lbnRGb3JQYXRoKHBhdGgpXG4gICAgICBsZXQgaXM0MDQgPSBwYXRoID09PSAnNDA0J1xuICAgICAgaWYgKCFDb21wKSB7XG4gICAgICAgIGlzNDA0ID0gdHJ1ZVxuICAgICAgICBDb21wID0gZ2V0Q29tcG9uZW50Rm9yUGF0aCgnLzQwNCcpXG4gICAgICB9XG4gICAgICByZXR1cm4gKG5ld1Byb3BzID0ge30pID0+IChcbiAgICAgICAgQ29tcFxuICAgICAgICAgID8gPENvbXAgey4uLm5ld1Byb3BzfSB7Li4uKGlzNDA0ID8ge3BhdGg6ICc0MDQnfSA6IHt9KX0gLz5cbiAgICAgICAgICA6IG51bGxcbiAgICAgIClcbiAgICB9XG5cbiAgICBjb25zdCByZW5kZXJQcm9wcyA9IHtcbiAgICAgIGNvbXBvbmVudHNCeVRlbXBsYXRlSUQ6IGdsb2JhbC5jb21wb25lbnRzQnlUZW1wbGF0ZUlELFxuICAgICAgdGVtcGxhdGVJRHNCeVBhdGg6IGdsb2JhbC50ZW1wbGF0ZUlEc0J5UGF0aCxcbiAgICAgIGdldENvbXBvbmVudEZvclBhdGg6IGdldEZ1bGxDb21wb25lbnRGb3JQYXRoXG4gICAgfVxuXG4gICAgaWYgKENvbXApIHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxDb21wXG4gICAgICAgICAgey4uLnJlbmRlclByb3BzfVxuICAgICAgICAvPlxuICAgICAgKVxuICAgIH1cblxuICAgIGlmIChyZW5kZXIgfHwgY2hpbGRyZW4pIHtcbiAgICAgIHJldHVybiAocmVuZGVyIHx8IGNoaWxkcmVuKShyZW5kZXJQcm9wcylcbiAgICB9XG5cbiAgICAvLyBUaGlzIGlzIHRoZSBkZWZhdWx0IGF1dG8tcm91dGluZyByZW5kZXJlclxuICAgIHJldHVybiAoXG4gICAgICA8Um91dGUgcmVuZGVyPXtwcm9wcyA9PiB7XG4gICAgICAgIGxldCBDb21wID0gZ2V0RnVsbENvbXBvbmVudEZvclBhdGgocHJvcHMubG9jYXRpb24ucGF0aG5hbWUpXG4gICAgICAgIC8vIElmIENvbXAgaXMgdXNlZCBhcyBhIGNvbXBvbmVudCBoZXJlLCBpdCB0cmlnZ2VycyBSZWFjdCB0byByZS1tb3VudCB0aGUgZW50aXJlXG4gICAgICAgIC8vIGNvbXBvbmVudCB0cmVlIHVuZGVybmVhdGggZHVyaW5nIHJlY29uY2lsaWF0aW9uLCBsb3NpbmcgYWxsIGludGVybmFsIHN0YXRlLlxuICAgICAgICAvLyBCeSB1bndyYXBwaW5nIGl0IGhlcmUgd2Uga2VlcCB0aGUgcmVhbCwgc3RhdGljIGNvbXBvbmVudCBleHBvc2VkIGRpcmVjdGx5IHRvIFJlYWN0LlxuICAgICAgICByZXR1cm4gQ29tcCAmJiBDb21wKClcbiAgICAgIH19IC8+XG4gICAgKVxuICB9XG59XG5cbmBcblxuICBjb25zdCBkeW5hbWljUm91dGVzUGF0aCA9IHBhdGguam9pbihwYXRocy5ESVNULCAncmVhY3Qtc3RhdGljLXJvdXRlcy5qcycpXG4gIGF3YWl0IGZzLnJlbW92ZShkeW5hbWljUm91dGVzUGF0aClcbiAgYXdhaXQgZnMub3V0cHV0RmlsZShkeW5hbWljUm91dGVzUGF0aCwgZmlsZSlcbn1cbiJdfQ==